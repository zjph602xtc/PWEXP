<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Piecewise Exponential Prediction Model</title>

<script src="site_libs/header-attrs-2.18/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/lumen.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="index.html">R package tutorial</a>
</li>
<li>
  <a href="https://github.com/zjph602xtc/PWEXP">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Piecewise Exponential Prediction Model</h1>

</div>


<p><br><br></p>
<div id="structure-of-package-pwexp" class="section level1">
<h1>Structure of Package ‘PWEXP’</h1>
<p><img src="images/structure2.png" /></p>
<p>The `PWEXP’package provides a complete set of tools to work with
survival data with piecewise exponential distribution. It also makes
event prediction based on the fitted model. Specifically, it has five
components for different tasks:</p>
<ul>
<li><strong>Simulate Data:</strong> (you can skip this part if you work
with an existing dataset)
<ul>
<li>the <code>simdata()</code> function generates synthetic survival
dataset with
<ul>
<li>randomization time defined by randomization rate (number of subjects
per month) or randomization curve (number of subjects in each
month)</li>
<li>multiple treatment groups with stratification by user-defined
allocation ratio</li>
<li>primary endpoint (event), drop-out (censor) and death with
exponential distribution or user-defined distributions (e.g., piecewise
exponential, mixture distribution, etc.) for each stratification in each
group</li>
</ul></li>
<li>the <code>plot_survival()</code> function plots KM estimator for the
right censored data</li>
<li>the <code>plot_event()</code> function plots the number of
cumulative events</li>
<li>auxiliary functions <code>dpwexp</code>, <code>ppwexp</code>,
<code>qpwexp</code>, <code>rpwexp</code> are the PDF, CDF, quantile
function, generator function for piecewise exponential distribution (See
<a href="#dist">‘Piecewise Exponential Distribution’ Section</a> for
more details)</li>
</ul></li>
<li><strong>Split Data:</strong>
<ul>
<li>the <code>cut_dat()</code> function cuts the data by a specified
time point. Only subjects who are randomized before the specified time
will be kept. It also recensors the data at the specified time. It is
useful to create a training set.</li>
</ul></li>
<li><strong>Fit a Piecewise Exponential Model:</strong>
<ul>
<li>the <code>pwexp.fit()</code> function fits the piecewise exponential
model to right censored data
<ul>
<li>with pre-specified breakpoints</li>
<li>or with partially pre-specified breakpoints</li>
<li>or with unknown breakpoints (to be fitted from the data)</li>
</ul></li>
<li>the <code>pwexp.fit()</code> function obtains model AIC, BIC</li>
<li>the <code>cv.pwexp.fit()</code> conducts model cross validation and
obtains the CV log likelihood</li>
<li>the <code>plot_survival()</code> plots fitted survival curve for
object <code>pwexp.fit</code></li>
</ul></li>
<li><strong>Bootstrap the Model to Get CI (optional):</strong>
<ul>
<li>the <code>boot.pwexp.fit()</code> conducts bootstrapping for an
existing model</li>
<li>the <code>plot_survival()</code> plots fitted survival curve and its
CI for object <code>boot.pwexp.fit</code></li>
</ul></li>
<li><strong>Prediction Events and Timeline</strong>
<ul>
<li>the <code>predict()</code> function takes event model and drop-out
(censor) model (optional) to make event prediction and timeline
prediction</li>
<li>the <code>predict()</code> function provides the CI of predicted
number of events or timeline (for bootstrapping model)</li>
<li>the <code>plot_event()</code> plots predicted number of events (for
object <code>predict.pwexp.fit</code>) and its CI (if applicable, for
object <code>predict.boot.pwexp.fit()</code>)</li>
<li>auxiliary functions <code>ppwexp_conditional()</code>,
<code>qpwexp_conditional()</code>, <code>rpwexp_conditional()</code> are
the CDF, quantile function, generator function for conditional piecewise
exponential distribution (See <a href="#con_dist">‘Conditional Piecewise
Exponential Distribution’ Section</a> for more details)</li>
</ul></li>
</ul>
<p><br></p>
</div>
<div id="install-package-pwexp" class="section level1">
<h1>0. Install Package ‘PWEXP’</h1>
<p>You need to install package <a
href="https://CRAN.R-project.org/package=fastmatch">fastmatch</a> before
installing <a href="https://github.com/zjph602xtc/PWEXP">PWEXP</a>.</p>
<pre class="r"><code>install.packages(&#39;fastmatch&#39;)
library(&#39;fastmatch&#39;)
library(&#39;PWEXP&#39;)

# or install package from Github
install.packages(&quot;devtools&quot;)
library(devtools)
install_github(&quot;zjph602xtc/PWEXP&quot;)</code></pre>
<p><br></p>
</div>
<div id="simulate-data" class="section level1">
<h1>1. Simulate Data</h1>
<div id="basic-usage-of-simdata" class="section level2">
<h2>1.1 Basic Usage of <code>simdata()</code></h2>
<p>You can skip this part if you work with an existing dataset. Here we
use <code>simdata()</code> function to generate a simple example
dataset:</p>
<ul>
<li>two groups with sample size ratio 1:2 (treatment vs. control);</li>
<li>randomization curve is defined as 10 pt/month in the first 2 months
and 5 pt/month in the following 20 months;</li>
<li>the primary endpoint (event) follows an exponential distribution
with hazard rate 0.01, 0.05 for treatment and control group;</li>
<li>the drop-out follows an exponential distribution with drop-out
probability 3%/month (equivalently, drop-out hazard rate is
-log(1-0.03)=0.0304) for both groups;</li>
<li>the death event follows an exponential distribution with hazard rate
0, 0.005 for each group;</li>
<li>argument <code>add_column</code> request some extra variables.</li>
</ul>
<pre class="r"><code>demo_dat0 &lt;- simdata(group = c(&#39;trt&#39;,&#39;control&#39;), n_rand = c(10,10,rep(5,20)),
                     allocation = c(1,2), event_lambda = c(0.01, 0.05), 
                     drop_rate = 0.03, death_lambda = c(0, 0.005), 
                     add_column = c(&#39;eventT_abs&#39;,&#39;dropT_abs&#39;,&#39;deathT_abs&#39;,&#39;followT&#39;,&#39;followT_abs&#39;,&#39;censor&#39;,&#39;event&#39;,&#39;censor_reason&#39;))
head(demo_dat0)</code></pre>
<pre><code>##   ID group      randT    eventT    dropT deathT eventT_abs dropT_abs deathT_abs
## 1  1   trt  0.6225994  80.20827 37.49508    Inf   80.83087  38.11768        Inf
## 2  2   trt  8.9574934  12.73224 34.16406    Inf   21.68974  43.12155        Inf
## 3  3   trt 19.7647359  41.60280 17.98190    Inf   61.36754  37.74663        Inf
## 4  4   trt  1.9460523 254.63692 46.49410    Inf  256.58297  48.44016        Inf
## 5  5   trt 17.5764884 215.03632 33.89415    Inf  232.61281  51.47063        Inf
## 6  6   trt  5.5198916  39.81326 16.37645    Inf   45.33315  21.89634        Inf
##    followT followT_abs censor event censor_reason
## 1 37.49508    38.11768      1     0      drop_out
## 2 12.73224    21.68974      0     1          &lt;NA&gt;
## 3 17.98190    37.74663      1     0      drop_out
## 4 46.49410    48.44016      1     0      drop_out
## 5 33.89415    51.47063      1     0      drop_out
## 6 16.37645    21.89634      1     0      drop_out</code></pre>
<p>In the generated dataset:</p>
<ul>
<li><code>randT</code> is the randomization time</li>
<li><code>eventT</code>, <code>dropT</code>, <code>deathT</code> are the
underlying primary event, drop-out, death time</li>
<li><code>followT</code> is the follow-up time, which is the minimum
value of <code>eventT</code>, <code>dropT</code>,
<code>deathT</code></li>
<li><code>eventT_abs</code>, <code>dropT_abs</code>,
<code>deathT_abs</code>, <code>followT_abs</code> are the corresponding
time from the beginning of the trial</li>
<li><code>cenosr</code>, <code>event</code> indicate whether the primary
event happened at the end of follow-up; if a subject is censored,
<code>censor_reason</code> shows the type of censoring (i.e.,
‘drop_out’,‘death’ or ‘never_event’(when followT=inf)))</li>
</ul>
<p>The diagram below shows the relationship between these variables:
<img src="images/simudata.png" /></p>
<p><br></p>
</div>
<div id="generate-data-with-user-defined-distributions"
class="section level2">
<h2>1.2 Generate Data with User-defined Distributions</h2>
<p><span style="color: #EB6864;font-weight:bold">In the follow parts of
the demonstration</span>, we will use a single group with piecewise
exponential distribution endpoint:</p>
<pre class="r"><code># define the piecewiese exponential event generation function
myevent_dist &lt;- function(n)rpwexp(n, rate=c(0.1, 0.01, 0.2), breakpoint=c(5,14))
# you can use any generation function in simdata function, for example, use a weibull density:
# myevent_dist &lt;- function(n)rweibull(n, shape=0.5, scale=10)
# use advanced_dist to adopt user-defined distribution, see function help for more details
dat &lt;- simdata(rand_rate = 20, total_sample = 1000, drop_rate = 0.03,  
               advanced_dist = list(event_dist=myevent_dist),
               add_column = c(&#39;censor_reason&#39;,&#39;event&#39;,&#39;followT&#39;,&#39;followT_abs&#39;))</code></pre>
<p>We can use the <code>plot_survival()</code> function to plot the
survival curve and cumulative number of events:</p>
<pre class="r"><code>plot_survival(dat$eventT, dat$event, conf.int = F, mark.time = T, xlim = c(0, 25), main=&#39;Survival Function of the Simu Data&#39;)
plot_event(dat$eventT, abs_time = F, dat$event, xlim = c(0, 25), main=&#39;Number of Cumulative Events of the Simu Data&#39;)</code></pre>
<p><img src="index_files/figure-html/figures-side-1.png" width="50%" height="100%" /><img src="index_files/figure-html/figures-side-2.png" width="50%" height="100%" />
<br></p>
</div>
</div>
<div id="split-data-to-obtain-traininginterim-data"
class="section level1">
<h1>2. Split Data to Obtain Training/Interim Data</h1>
<p>We cut the dataset by the time when 80% percent subject are
randomized. Only subjects who are randomized before the specified time
will be kept in the returned data. The returned data will be recensored
at the specified time. This step is to create a training set. In real
data analysis, this step may not be needed.</p>
<pre class="r"><code>cut &lt;- quantile(dat$randT, 0.8)
train &lt;- cut_dat(cut = cut, data = dat, var_randT = &#39;randT&#39;, 
                 var_followT = &#39;followT&#39;, var_followT_abs = &#39;followT_abs&#39;,
                 var_event = &#39;event&#39;, var_censor_reason = &#39;censor_reason&#39;)</code></pre>
<p><br></p>
</div>
<div id="model" class="section level1">
<h1>3. Fit a Piecewise Exponential Model</h1>
<p>We will fit several piecewise exponential models on the training
set:</p>
<ul>
<li><code>fit_a0</code> has pre-specified breakpoints at time = 5,
14</li>
<li><code>fit_a1</code> has one pre-specified breakpoint at time = 14,
and the total number of breakpoint is 2. The other breakpoint will be
estimated from the data</li>
<li><code>fit_b0</code> to <code>fit_b4</code> have 0 to 4 unknown
breakpoints. Note the <code>fit_b0</code> model is actually an
exponential model since there is NO breakpoints.</li>
</ul>
<pre class="r"><code>fit_a0 &lt;- pwexp.fit(train$followT, train$event, breakpoint = c(5,14))
fit_a1 &lt;- pwexp.fit(train$followT, train$event, nbreak = 2, breakpoint = c(14))
# argument &#39;exclude_int&#39; defines an interval that excludes any estimated breakpoints. for example:
# fit_a1 &lt;- pwexp.fit(train$followT, train$event, nbreak = 2, breakpoint = c(5), exclude_int=c(8,Inf))
fit_b0 &lt;- pwexp.fit(train$followT, train$event, nbreak = 0)
fit_b1 &lt;- pwexp.fit(train$followT, train$event, nbreak = 1)
fit_b2 &lt;- pwexp.fit(train$followT, train$event, nbreak = 2)
fit_b3 &lt;- pwexp.fit(train$followT, train$event, nbreak = 3)
fit_b4 &lt;- pwexp.fit(train$followT, train$event, nbreak = 4)</code></pre>
<p>We plot BIC of these models and find that among all models without
pre-specified breakpoints, <code>fit_b2</code> with the correct number
of breakpoints has the lowest BIC value. We can also use cross
validation to help us choose the model. The model <code>fit_b2</code>
with the correct number of breakpoints has the highest CV log
likelihood.</p>
<pre class="r"><code>library(&#39;RColorBrewer&#39;)
model_name &lt;- c(&#39;2 fixed breakpoints&#39;, &#39;1 fixed + 1 unknown bkp&#39;, &#39;0 unknown bkp (exp model)&#39;, &#39;1 unknown bkp&#39;, &#39;2 unknown bkp&#39;, &#39;3 unknown bkp&#39;, &#39;4 unknown bkp&#39;)
model_ind &lt;- c(&#39;a0&#39;,&#39;a1&#39;,paste0(&#39;b&#39;,0:4))
col &lt;- c(brewer.pal(3, &#39;Pastel1&#39;)[1:2], brewer.pal(9, &#39;Greens&#39;)[3:7])

# Plot BIC for each model
barplot(c(fit_a0$BIC, fit_a1$BIC, fit_b0$BIC, fit_b1$BIC, fit_b2$BIC, fit_b3$BIC, fit_b4$BIC), xlab=&#39;Model&#39;, ylab=&#39;BIC&#39;, ylim=c(2700,3400), xpd=F, col=col, names.arg=model_ind, main=&#39;BIC of Fitted Models&#39;)
legend(&#39;topleft&#39;, model_name, fill=col, ncol=2, text.width=3.5)

# Cross validate fitted models
nsim &lt;- 50
fit_a0_cv &lt;- cv.pwexp.fit(fit_a0, nsim = nsim)
fit_a1_cv &lt;- cv.pwexp.fit(fit_a1, nsim = nsim)
fit_b0_cv &lt;- cv.pwexp.fit(fit_b0, nsim = nsim)
fit_b1_cv &lt;- cv.pwexp.fit(fit_b1, nsim = nsim)
fit_b2_cv &lt;- cv.pwexp.fit(fit_b2, nsim = nsim)
fit_b3_cv &lt;- cv.pwexp.fit(fit_b3, nsim = nsim)
# alternatively, we can specify a new model in the cv.pwexp.fit function instead of CV a fitted model, for example:
fit_b4_cv &lt;- cv.pwexp.fit(train$followT, train$event, nbreak=4, nsim=nsim)
boxplot(cv~model_ind, data.frame(cv=c(fit_a0_cv, fit_a1_cv, fit_b0_cv, fit_b1_cv, fit_b2_cv, fit_b3_cv, fit_b4_cv), model_ind=rep(model_ind, each=nsim)), ylab=&#39;CV log likelihood&#39;, xlab=&#39;Model&#39;, ylim=c(-320,-250), col=col, main=&#39;CV log likelihood of Fitted Models&#39;)
legend(&#39;topleft&#39;, model_name, fill=col, ncol=2, text.width=3)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-7-1.png" width="50%" height="100%" /><img src="index_files/figure-html/unnamed-chunk-7-2.png" width="50%" height="100%" /></p>
<p>We then plot the fitted curves of some of these models.</p>
<pre class="r"><code># Plot fitted survival curves
plot_survival(train$followT, train$event, xlim=c(0,40), main=&#39;Fitted Models with Different \nNumber of Breakpoints&#39;)
plot_survival(fit_b0, col=&#39;green&#39;, lwd=2)
plot_survival(fit_b1, col=&#39;blue&#39;, lwd=3, show_breakpoint = F)
plot_survival(fit_b2,  col=&#39;red&#39;, lwd=3, breakpoint_par = list(col=&#39;grey50&#39;, lty=2))
plot_survival(fit_b3, col=&#39;orange&#39;, lwd=3, show_breakpoint = F)
legend(&#39;topright&#39;,c(&#39;training data&#39;, &#39;0 breakpoints&#39;,&#39;1 breakpoint&#39;,&#39;2 breakpoints&#39;,&#39;3 breakpoints&#39;), lwd=3, col=c(&#39;black&#39;, &#39;green&#39;,&#39;blue&#39;,&#39;red&#39;,&#39;orange&#39;))</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-8-1.png" width="480" />
<br></p>
</div>
<div id="bootstrap-model-optional" class="section level1">
<h1>4. Bootstrap Model (optional)</h1>
<p>We will use bootstrap to estimate the uncertainty of estimated
parameters. We take model <code>fit_b2</code> as an example.</p>
<pre class="r"><code># bootstrap the model
fit_b2_boot &lt;- boot.pwexp.fit(fit_b2, nsim = 50)

# plot data and the fitted model with 95% CI
plot_survival(train$followT, train$event, xlim=c(0,40), main=&#39;Fitted Model for Primary Events with 95% CI&#39;)
plot_survival(fit_b2_boot, col=&#39;red&#39;, alpha=0.05, CI_par = list(col=&#39;#ff9896&#39;))
# plot 95% CI of estimated breakpoints
brk_ci &lt;- apply(attr(fit_b2_boot, &#39;brk&#39;), 2, function(x)quantile(x,c(0.025,0.975)))
abline(v=brk_ci, col=&#39;grey&#39;, lwd=2, lty=3)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-9-1.png" width="480" />
<br></p>
</div>
<div id="prediction-future-events-timeline" class="section level1">
<h1>5. Prediction Future Events &amp; Timeline</h1>
<p>In order to do prediction, we also need to build a model for drop-out
and death (the censoring model) in addition to the event model. The
censoring model is very similar to the event model in <a
href="#model">Section 3</a>, but the response of the model is drop-out
and death instead of the primary events. The model is optional when the
drop-out (and death) rate is very low.</p>
<p>Here, <code>drop_indicator</code> is a time-to-event endpoint that
represents the time of drop-out (and we do not have death in the
simulated data), and it will be used as the response variable in the
censoring model. We will fit an exponential model with
bootstrapping.</p>
<pre class="r"><code>drop_indicator &lt;-  ifelse(train$censor_reason==&#39;drop_out&#39; &amp; !is.na(train$censor_reason),1,0)
plot_survival(train$followT, drop_indicator, xlim=c(0,40), ylab=&#39;Survival function of drop-out&#39;, main=&#39;Fitted Censoring Model for Drop-out with 95% CI&#39;)
fit_censor_boot &lt;- boot.pwexp.fit(train$followT, drop_indicator, nbreak = 0, nsim = 50)
plot_survival(fit_censor_boot, col=&#39;red&#39;, alpha=0.01, CI_par = list(col=&#39;#ff9896&#39;))</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-10-1.png" width="480" /></p>
<p>Finally, we use <code>predict()</code> function to predict the number
of events in the future. Note the returned object from
<code>predict()</code> contains event curve functions and it should be
used in <code>plot_event()</code> function to obtain the estimated
events and to plot the curve.</p>
<pre class="r"><code>predicted_boot &lt;- predict(event_model_boot=fit_b2_boot, analysis_time=cut, censor_model_boot=fit_censor_boot, future_rand=list(rand_rate=20, total_sample=NROW(dat)-NROW(train)))</code></pre>
<p>We use <code>plot_event()</code> function to plot the event
curve:</p>
<pre class="r"><code>plot_event(dat$followT_abs, abs_time=T, event=dat$event, ylim=c(0, 800), main=&#39;Predicted Number of Events&#39;)
plot_event(train$followT_abs, abs_time=T, event=train$event, add=T, col=&#39;blue&#39;)
pred_event &lt;- plot_event(predicted_boot, eval_at = seq(40, 90, 5))
legend(&#39;bottomright&#39;, c(&#39;data used to train model&#39;, &#39;true event curve&#39;, &#39;predicted event curve&#39;), lwd=2, col=c(&#39;blue&#39;, &#39;black&#39;, &#39;red&#39;))</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-12-1.png" width="480" /></p>
<p>Here is the estimated number of events specified by argument
<code>eval_at</code>:</p>
<pre class="r"><code>head(pred_event)</code></pre>
<pre><code>##      time  n_event 5% n_event 95% n_event
## [1,]   40       NA         NA          NA
## [2,]   45 521.3411   508.5447    533.5793
## [3,]   50 598.3542   580.9918    615.0000
## [4,]   55 649.0046   632.1919    667.0013
## [5,]   60 681.0858   665.0000    700.6344
## [6,]   65 709.7883   695.0560    729.3508</code></pre>
<p><br></p>
<p>By adding argument <code>xyswitch=TRUE</code>, we can use
<code>predict()</code> function to obtain the timeline given the number
of events in the future.</p>
<pre class="r"><code>plot_event(dat$followT_abs, xlim=c(0, 800), event=dat$event, xyswitch=T, main=&#39;Predicted Timeline&#39;)
plot_event(train$followT_abs, abs_time=T, event=train$event, add=T, xyswitch=T, col=&#39;blue&#39;)
pred_time &lt;- plot_event(predicted_boot, xyswitch=T, eval_at = seq(500, 700, 50))
legend(&#39;bottomright&#39;, c(&#39;data used to train model&#39;, &#39;true timeline&#39;, &#39;predicted timeline&#39;), lwd=2, col=c(&#39;blue&#39;, &#39;black&#39;, &#39;red&#39;))</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-14-1.png" width="480" /></p>
<pre class="r"><code>head(pred_time)</code></pre>
<pre><code>##      n_event     time  5% time 95% time
## [1,]     500 43.61689 42.98982 44.39533
## [2,]     550 46.87314 45.95741 47.84667
## [3,]     600 50.11711 49.08859 51.37802
## [4,]     650 55.15592 52.80026 57.56297
## [5,]     700 63.22742 59.89260 66.36540</code></pre>
<p><br></p>
</div>
<div id="appendix" class="section level1">
<h1>Appendix</h1>
<div id="a.-distribution" class="section level2">
<h2>A. Distribution</h2>
<div id="dist" class="section level3">
<h3>A.1 Piecewise Exponential Distribution</h3>
<p>The hazard function, cumulative hazard function, PDF, CDF, quantile
function of an exponential distribution r.v. <span
class="math inline">\(t\)</span> are: <span
class="math display">\[\begin{align*}
    h(t)&amp;=\lambda\\
    H(t)&amp;=\lambda t\\
    f(t)&amp;=\lambda e^{-\lambda t}\\
    F(t)&amp;=1-e^{-\lambda t}\\
    Q(p)&amp;=\frac{-\log(1-p)}{\lambda}
\end{align*}\]</span> The hazard function, cumulative hazard function,
PDF, survival function, quantile function of a piecewise exponential
distribution r.v. <span class="math inline">\(t\)</span> with
breakpoints <span class="math inline">\(d_i\)</span> are: <span
class="math display">\[\begin{align*}
    h(t)&amp;=\begin{cases}
        \lambda_1, &amp; t&lt;d_1\\
        \lambda_2, &amp; d_1\le t&lt;d_2\\
        \cdots\\
        \lambda_{r+1}, &amp; t\ge d_r
    \end{cases}\\
    H(t)&amp;=\begin{cases}
        \lambda_1 t, &amp; t&lt;d_1\\
        (\lambda_1-\lambda_2)d_1+\lambda_2t , &amp; d_1\le t&lt;d_2\\
        \cdots\\
        \left[\sum_{i=1}^r(\lambda_i-\lambda_{i+1})d_i\right]+\lambda_{r+1}t,
&amp; t\ge d_r
    \end{cases}\\
    f(t)=h(t)e^{-H(t)}&amp;=\begin{cases}
        \lambda_1 e^{-\lambda_1 t}, &amp; t&lt;d_1\\
        \lambda_2 e^{(\lambda_2-\lambda_1)d_1-\lambda_2t} , &amp; d_1\le
t&lt;d_2\\
        \cdots\\
        \lambda_{r+1}e^{\left[\sum_{i=1}^r(\lambda_{i+1}-\lambda_{i})d_i\right]-\lambda_{r+1}t},
&amp; t\ge d_r
    \end{cases}\\
    S(t)=e^{-H(t)}&amp;=\begin{cases}
        e^{-\lambda_1 t}, &amp; t&lt;d_1\\
        e^{(\lambda_2-\lambda_1)d_1-\lambda_2t} , &amp; d_1\le
t&lt;d_2\\
        \cdots\\
        e^{\left[\sum_{i=1}^r(\lambda_{i+1}-\lambda_{i})d_i\right]-\lambda_{r+1}t},
&amp; t\ge d_r
    \end{cases}\\\\
    Q(p)&amp;=\begin{cases}
        \frac{-\log(1-p)}{\lambda_1} &amp; p&lt; 1-e^{-\lambda d_1}\\
        \frac{(\lambda_2-\lambda_1)d_1-\log(1-p)}{\lambda_2} &amp;
1-e^{-\lambda d_1}\le p&lt; 1-e^{(\lambda_2-
        \lambda_1)d_1-\lambda_2 d_2}\\
        \cdots\\
        \frac{\left[\sum_{i=1}^r
(\lambda_{i+1}-\lambda_i)d_i\right]-\log(1-p)}{\lambda_{r+1}} &amp; p\ge
1-e^{\left[\sum_{i=1}^r(\lambda_{i+1}-\lambda_{i})d_i\right]-\lambda_{r+1}d_r}\\
    \end{cases}
\end{align*}\]</span></p>
<p>The <code>PWEXP</code> package provides <code>dpwexp()</code>,
<code>ppwexp()</code>, <code>qpwexp()</code>, <code>rpwexp()</code>
functions to the piecewise exponential distribution:</p>
<pre class="r"><code># Left Figure ------------------------------------------------------------
# use rpwexp function to generate piecewise exp samples with rate 2, 1, 3
r_sample &lt;- rpwexp(50000, rate=c(2, 1, 3), breakpoint=c(0.3, 0.8))
hist(r_sample, freq=F, breaks=200, main=&quot;Density of Piecewsie Exp Dist&quot;, xlab=&#39;t&#39;, xlim=c(0, 1.2))

# piecewise exp density with rate 2, 1, 3 
t &lt;- seq(0, 1.5, 0.01)
f2 &lt;- dpwexp(t, rate=c(2, 1, 3), breakpoint=c(0.3, 0.8))
points(t, f2, col=&#39;red&#39;, pch=16)

# exp distribution can be a special case of piecewise exp distribution
f1 &lt;- dpwexp(t, rate=2) 
lines(t, f1, lwd=2)
legend(&#39;topright&#39;, c(&#39;exp dist with rate 2&#39;,&#39;piecewise exp dist with rate 2, 1, 3&#39;,&#39;histogram of piecewise exp dist with rate 2, 1, 3&#39;), col=c(&#39;black&#39;,&#39;red&#39;), fill=c(NA, NA, &#39;grey&#39;), border=c(&#39;white&#39;, &#39;white&#39;, &#39;black&#39;), lty=c(1, NA, NA), pch=c(NA, 16, NA), lwd=2)

# Right Figure ------------------------------------------------------------
# CDF of piecewise exp with rate 2, 1, 3
F2 &lt;- ppwexp(t, rate=c(2, 1, 3), breakpoint=c(0.3, 0.8), lower.tail=T)
plot(t, F2, type=&#39;l&#39;, col=&#39;red&#39;, lwd=2, main=&quot;CDF and Quantile Function of Piecewsie Exp Dist&quot;, xlim=c(0, 1.5), ylim=c(0, 1.5))

# CDF of exp dist is compatible with our package
F1 &lt;- ppwexp(t, rate=2, lower.tail=T)
lines(t, F1, lwd=2)

# plot quantile functions of both distributions
lines(F1, qpwexp(F1, rate=2, lower.tail=T), lty=2, lwd=2)
lines(F2, qpwexp(F2, rate=c(2, 1, 3), breakpoint=c(0.3,0.8), lower.tail=T), col=&#39;red&#39;, lty=2, lwd=2)

abline(0, 1, col=&#39;grey&#39;)
legend(&#39;topleft&#39;, c(&#39;CDF of piecewise exp with rate 2, 1, 3&#39;, &#39;quantile function of piecewise exp with rate 2, 1, 3&#39;, &#39;CDF of exp with rate 2&#39;, &#39;quantile function of exp with rate 2&#39;), col=c(&#39;red&#39;, &#39;red&#39;, &#39;black&#39;, &#39;black&#39;), lty=c(1, 2, 1, 2), lwd=2)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-15-1.png" width="50%" height="100%" /><img src="index_files/figure-html/unnamed-chunk-15-2.png" width="50%" height="100%" /></p>
</div>
<div id="con_dist" class="section level3">
<h3>A.2 Conditional Piecewise Exponential Distribution</h3>
<p>The conditional survival function, CDF, PFD and quantile function of
an exponential distribution <span class="math inline">\(t\)</span> given
<span class="math inline">\(t&gt;T\)</span> is <span
class="math display">\[\begin{align*}
    S(t|t&gt;T)&amp;=\frac{S(t)}{S(T)}=e^{\lambda T-\lambda t}\\
    F(t|t&gt;T)&amp;=1-\frac{S(t)}{S(T)}=1-e^{\lambda T-\lambda t}\\
    f(t|t&gt;T)&amp;=\lambda e^{\lambda T-\lambda t}\\
    Q(p|t&gt;T)&amp;=\frac{\lambda T-\log(1-p)}{\lambda}
\end{align*}\]</span></p>
<p>The conditional survival function and CDF of a piecewise exponential
distribution <span class="math inline">\(t\)</span> given <span
class="math inline">\(t&gt;T\)</span> is <span
class="math display">\[\begin{align*}
    S(t|t&gt;T)&amp;=\frac{S(t)}{S(T)}, \text{ then plug in $S(t)$,
$S(T)$}\\
    F(t|t&gt;T)&amp;=1-\frac{S(t)}{S(T)}, \text{ then plug in $S(t)$,
$S(T)$}
\end{align*}\]</span> The conditional quantile function of a piecewise
exponential distribution <span class="math inline">\(t\)</span> given
<span class="math inline">\(t&gt;T\)</span> is <span
class="math display">\[\begin{align*}
    Q(p|t&gt;T)=\begin{cases}
        \frac{\lambda_1 T-\log(1-p)}{\lambda_{1}}, &amp;
        \hspace{-60pt} p &lt;F(d_{1}|t&gt;T), T &lt;d_{1}\\
        \frac{\left[\sum_{i=1}^{k-1}
(\lambda_{i+1}-\lambda_i)d_i\right]+\lambda_1 T-\log(1-p)}{\lambda_{k}},
&amp; \\
        &amp;\hspace{-60pt} F(d_{k-1}|t&gt;T)\le p &lt;F(d_{k}|t&gt;T),
T &lt;d_{1}\\
        \frac{\left[\sum_{i=m}^{k-1}
(\lambda_{i+1}-\lambda_i)d_i\right]+\lambda_m T-\log(1-p)}{\lambda_{k}},
&amp; \\
        &amp;\hspace{-60pt} F(d_{k-1}|t&gt;T)\le p &lt;F(d_{k}|t&gt;T),
d_{m-1}\le T &lt;d_{m}
    \end{cases}
\end{align*}\]</span> The <code>PWEXP</code> package provides
<code>ppwexp_conditional()</code>, <code>qpwexp_conditional()</code>,
<code>rpwexp_conditional()</code> functions for conditional piecewise
exponential distribution:</p>
<pre class="r"><code># Left Figure ------------------------------------------------------------
# CDF and qunatile function of conditional piecewise exp with rate 2, 1, 3 given t &gt; 0.1
t &lt;- seq(0.1, 1.2, 0.01)
F2_con &lt;- ppwexp_conditional(t, qT=0.1, rate=c(2, 1, 3), breakpoint=c(0.3, 0.8))
plot(t, F2_con, type=&#39;l&#39;, col=&#39;red&#39;, lwd=2, main=&quot;CDF and Quantile Function of Conditional \nPiecewsie Exp Dist&quot;, xlim=c(0, 1.2), ylim=c(0, 1.2))
lines(F2_con, qpwexp_conditional(F2_con, qT=0.1, rate=c(2, 1, 3), breakpoint=c(0.3,0.8)), lty=2, lwd=2, col=&#39;red&#39;)

# compare with CDF and quantile function of unconditional piecewise exp with rate 2, 1, 3
t &lt;- seq(0, 1.2, 0.01)
F2 &lt;- ppwexp(t, rate=c(2, 1, 3), breakpoint=c(0.3,0.8))
lines(t, F2, lwd=2)
lines(F2, qpwexp(F2, rate=c(2, 1, 3), breakpoint=c(0.3,0.8)), lty=2, lwd=2)
abline(v=0.1, col=&#39;grey&#39;)
abline(h=0.1, col=&#39;grey&#39;)
legend(&#39;topleft&#39;, c(&#39;CDF of piecewise exp dist given t &gt; 0.1&#39;, &#39;quantile function of piecewise exp dist given t &gt; 0.1&#39;, &#39;CDF of piecewise exp dist&#39;, &#39;quantile function of piecewise exp dist&#39;), col=c(&#39;red&#39;, &#39;red&#39;, &#39;black&#39;, &#39;black&#39;), lty=c(1, 2, 1, 2), lwd=2)

# Right Figure ------------------------------------------------------------
# use rpwexp_conditional function to generate piecewise exp samples with rate 2, 1, 3 given t &gt; 0.1
r_sample_con &lt;- rpwexp_conditional(3000, qT=0.1, rate=c(2, 1, 3), breakpoint=c(0.3,0.8))
plot(ecdf(r_sample_con), col=&#39;red&#39;, lwd=2,  main=&quot;Empirical CDF of Conditional Piecewsie Exp Dist&quot;, xlim=c(0, 1.2), ylim=c(0, 1))

# compare with its CDF
lines(seq(0.1, 1.2, 0.01), F2_con, lwd=2, lty=2)
legend(&#39;topleft&#39;, c(&#39;empirial CDF of piecewise exp dist given t &gt; 0.1&#39;, &#39;true CDF of piecewise exp dist given t &gt; 0.1&#39;), col=c(&#39;red&#39;, &#39;black&#39;), lty=c(1,2), lwd=2)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-16-1.png" width="50%" height="100%" /><img src="index_files/figure-html/unnamed-chunk-16-2.png" width="50%" height="100%" />
<br></p>
</div>
</div>
<div id="b.-estimation-of-piecewise-exponential-model"
class="section level2">
<h2>B. Estimation of Piecewise Exponential Model</h2>
<div id="b.1-parameter-estimation" class="section level3">
<h3>B.1 Parameter Estimation</h3>
<div id="hazard" class="section level4">
<h4>B.1.1 Hazard Rate Estimation with Known Breakpoints</h4>
<p>The log likelihood function can be constructed as following: <span
class="math display">\[\begin{align}
    \log(L)=&amp;\sum_{j\in D_1}\left[\log(\lambda_1)-\lambda_1
t_j\right]+\sum_{j\in C_1}\left[-\lambda_1 t_j\right]\\
    &amp;\quad +\sum_{j\in
D_2}\left[\log(\lambda_2)+(\lambda_2-\lambda_1)d_1-\lambda_2
t_j\right]+\sum_{j\in C_2}\left[(\lambda_2-\lambda_1)d_1-\lambda_2
t_j\right]\\
    &amp;\quad +\cdots \\
    &amp;\quad +\sum_{j\in D_{r+1}}\left\{\log(\lambda_{r+1})
+\sum_{i=1}^r \left[(\lambda_{i+1}-\lambda_i)d_i\right]-\lambda_{r+1}
t_j\right\}+\sum_{j\in C_{r+1}}\left\{\sum_{i=1}^r
\left[(\lambda_{i+1}-\lambda_i)d_i\right]-\lambda_{r+1} t_j\right\}
\end{align}\]</span> where <span class="math inline">\(D_r\)</span> or
<span class="math inline">\(C_r\)</span> are the index set of event time
or censoring time that fall into <span
class="math inline">\(r\)</span>th interval of the piecewise exponential
distribution.</p>
<p>When breakpoints <span class="math inline">\(d_1\)</span> to <span
class="math inline">\(d_r\)</span> are known, we can take a derivative
of <span class="math inline">\(\log(L)\)</span> wrt <span
class="math inline">\(\lambda\)</span>: <span
class="math display">\[\begin{align}
    \frac{\partial \log(L)}{\partial \lambda_1}=&amp;\sum_{j\in
D_1}\left[1/\lambda_1- t_j\right]+\sum_{j\in C_1}\left[-t_j\right]
    +\sum_{j\in D_2}\left[-d_1\right]+\sum_{j\in C_2}\left[-d_1\right]
     +\cdots
    +\sum_{j\in D_{r+1}}\left[-d_1\right]+\sum_{j\in
C_{r+1}}\left[-d_1\right]\\
    =&amp;\frac{n_{D_1}}{\lambda_1}-\sum_{j\in C_1}t_j- n_{2^+}d_1\\
    \frac{\partial \log(L)}{\partial \lambda_2}=&amp;\sum_{j\in
D_2}\left[1/\lambda_2+d_1-t_j\right]+\sum_{j\in C_2}\left[d_1-
t_j\right]
    +\cdots
    +\sum_{j\in D_{r+1}}\left[-d_2+d_1\right]+\sum_{j\in
C_{r+1}}\left[-d_2+d_1\right]\\
    =&amp;\frac{n_{D_2}}{\lambda_2}-\sum_{j\in D_2, C_2}(t_j-d_1)-
n_{3^+}(d_2-d_1)\\
    &amp;\cdots\\
    \frac{\partial \log(L)}{\partial
\lambda_r}=&amp;\frac{n_{D_r}}{\lambda_r}-\sum_{j\in D_r,
C_r}(t_j-d_{r-1})- n_{r+1^+}(d_r-d_{r-1})\\
    \frac{\partial \log(L)}{\partial
\lambda_{r+1}}=&amp;\frac{n_{D_{r+1}}}{\lambda_{r+1}}-\sum_{j\in
D_{r+1}, C_{r+1}}(t_j-d_{r})
\end{align}\]</span> where <span class="math inline">\(n_{D_r}\)</span>
is the number of events that fall into the <span
class="math inline">\(r\)</span>th interval; <span
class="math inline">\(n_{r^+}\)</span> is the number of events and
censoring that fall into the <span class="math inline">\(r\)</span>th to
the end intervals.</p>
<p>Let all derivatives equal to 0, we obtain the MLE estimator of hazard
rates: <span class="math display">\[\begin{align}
    {\hat \lambda}_1=&amp;\frac{n_{D_1}}{\sum_{j\in C_1}t_j+
n_{2^+}d_1}\\
    {\hat \lambda}_2=&amp;\frac{n_{D_2}}{\sum_{j\in D_2, C_2}(t_j-d_1)+
n_{3^+}(d_2-d_1)}\\
    &amp;\cdots \\
    {\hat \lambda}_r=&amp;\frac{n_{D_r}}{\sum_{j\in D_r,
C_r}(t_j-d_{r-1})+ n_{r+1^+}(d_r-d_{r-1})}\\
    {\hat \lambda}_{r+1}=&amp;\frac{n_{D_{r+1}}}{\sum_{j\in D_{r+1},
C_{r+1}}(t_j-d_r)}
\end{align}\]</span></p>
</div>
</div>
<div id="b.2-estimation-of-breakpoints" class="section level3">
<h3>B.2 Estimation of Breakpoints</h3>
<div id="mle" class="section level4">
<h4>B.2.1 MLE by Brute-force Search</h4>
<p>The log likelihood function is differentiable wrt <span
class="math inline">\(d_r\)</span> as long as <span
class="math inline">\(d_r\)</span> is not equal to any event time or
censoring time. We take the derivative of <span
class="math inline">\(\log(L)\)</span> wrt <span
class="math inline">\(d_r\)</span>: <span
class="math display">\[\begin{align}
    \frac{\partial \log(L)}{\partial d_r}=&amp;\sum_{j\in
D_{r+1}}\left[\lambda_{r+1}-\lambda_r\right]+\sum_{j\in
C_{r+1}}\left[\lambda_{r+1}-\lambda_r\right]\\
    =&amp;n_{r+1^+}(\lambda_{r+1}-\lambda_r)
\end{align}\]</span> Since <span class="math inline">\(\lambda_{r+1}\ne
\lambda_r\)</span>, then the derivative cannot be zero when <span
class="math inline">\(d_r\)</span> is between two consecutive sample
time points. This fact implies that only when <span
class="math inline">\(d_r\)</span> is equal to any of the sample values,
the log likelihood function achieves the maximum value.</p>
<p>Therefore, we can use a brute-force search to calculate the log
likelihood function values for all potential breakpoint combinations.
For each candidate, hazard rates can be estimated by the formula in <a
href="#hazard">Section B.1.1</a> and thus the log likelihood can be
obtained. The breakpoints and hazard rates with the largest log
likelihood value are the MLE estimator.</p>
<p>When the number of samples or the number of breakpoints are
relatively large, the combination of breakpoints will be very large and
the brute-force search may not be feasible. We will draw a random
sub-sample first and then do exhaustive search based on the sub-sample.
The argument in function controls the maximum combination candidates to
try.</p>
</div>
<div id="ols" class="section level4">
<h4>B.2.2 OLS on Survival Function</h4>
<p>The second method to estimate breakpoints is based on the survival
curve. Once we take a log transformation of the piecewise survival
function, we will obtain a piecewise linear function: <span
class="math display">\[\begin{align}
    \log(S(t))=&amp;\begin{cases}
        {-\lambda_1 t}, &amp; t&lt;d_1\\
        {(\lambda_2-\lambda_1)d_1-\lambda_2t} , &amp; d_1\le t&lt;d_2\\
        \cdots\\
        {\left[\sum_{i=1}^r(\lambda_{i+1}-\lambda_{i})d_i\right]-\lambda_{r+1}t},
&amp; t\ge d_r
    \end{cases}\\
    =&amp;-\lambda_1 t +(\lambda_1-\lambda_2) (t-d_1)_+\cdots
+(\lambda_r-\lambda_{r+1})(t-d_r)_+
\end{align}\]</span></p>
<p>Let <span class="math inline">\(Y_i\)</span> be the log value of KM
estimate at <span class="math inline">\(t_i\)</span>. Following <a
href="#ref">Muggeo (2003)</a>, we use <span class="math inline">\((t_i,
Y_i)\)</span> to fit the piecewise log survival function <span
class="math inline">\(\log(S(t))\)</span> and obtain the OLS breakpoints
<span class="math inline">\(\hat d_r\)</span>. Once breakpoints are
determined, hazard rates can be estimated by the formula in <a
href="#hazard">Section B.1.1</a>.</p>
</div>
<div id="b.2.3-hybrid-method" class="section level4">
<h4>B.2.3 Hybrid Method</h4>
<p>The breakpoints estimated in <a href="#ols">Section B.2.2</a> are not
exactly but very close to the MLE estimator. In order to obtain the MLE
estimator, we combine brute-force search with OLS method.</p>
<p>Specifically, instead of drawing a random sub-sample in <a
href="#mle">Section B.2.1</a>, we draw a sub-sample from the values
within 95% percent confidence intervals of the estimated breakpoints
from <a href="#ols">Section B.2.2</a>. Then we do exhaustive search
based on the sub-sample. The argument in function controls the maximum
combination candidates to try. The hybrid method improves the efficiency
and accuracy of the estimation procedure.</p>
</div>
</div>
<div id="b.3-summary" class="section level3">
<h3>B.3 Summary</h3>
<p>The procedure of parameter estimation is summarized in the diagram
below:</p>
<p><img src="images/estimation.png" width="650" /></p>
<p><br></p>
</div>
</div>
<div id="c.-simulate-event-curve-or-timeline" class="section level2">
<h2>C. Simulate Event Curve or Timeline</h2>
<p>We can use the <code>sim_followup()</code> function to estimate the
event curve or timeline at the trial design stage. The piecewise hazard
rate comes from clinical suggestions or data curve fit from previous
literature.</p>
<p>For example, here we assume we have two groups:</p>
<ul>
<li>two groups with sample size ratio 1:2 (treatment vs. control);</li>
<li>randomization rate is 20 pt/month and the total sample size is
1000;</li>
<li>the primary endpoint (event) follows an piecewise distribution with
hazard rate 0.1, 0.01, 0.02 at breakpoints 5, 14 for the control group;
the hazard ratio (treatment vs. control) is 0.7.</li>
</ul>
<p>We want to estimate the number of events every 10 months from month
20. We can also estimate the time needed given the number of events.</p>
<pre class="r"><code># define the piecewiese exponential event generation function
myevent_dist_trt &lt;- function(n)rpwexp(n, rate=c(0.1, 0.01, 0.2)*0.7, breakpoint=c(5,14))
myevent_dist_con &lt;- function(n)rpwexp(n, rate=c(0.1, 0.01, 0.2), breakpoint=c(5,14))

# user defined summary function: the proportion of subjects that are followed more than 12 month
prop_12 &lt;- function(x)mean(x &gt;= 12)

# estimate the event curve or timeline:
event_curve &lt;- sim_followup(at=seq(20,90,10), type = &#39;calendar&#39;, group = c(&#39;trt&#39;,&#39;con&#39;),
             rand_rate = 20, total_sample = 1000, drop_rate = 0.03, allocation = 1:2,
             advanced_dist = list(event_dist=c(myevent_dist_trt, myevent_dist_con)),
             by_group = T, stat = c(median, prop_12), start_date = &quot;2020-01-01&quot;, rep=50)
time_curve &lt;- sim_followup(at=seq(200,600,50), type = &#39;event&#39;, group = c(&#39;trt&#39;,&#39;con&#39;),
                    rand_rate = 20, total_sample = 1000, drop_rate = 0.03, allocation = 1:2,
                    advanced_dist = list(event_dist=c(myevent_dist_trt, myevent_dist_con)),
                    stat = c(median, prop_12), start_date = &quot;2020-01-01&quot;, rep=50)
# plot event curve or timeline
plot(event_curve$T_all$analysis_time_c, event_curve$T_all$event, xlab=&#39;Time&#39;, ylab=&#39;Number of events&#39;, type=&#39;b&#39;, main=&#39;Event curve&#39;, lwd=2)
plot(time_curve$T_all$event, time_curve$T_all$analysis_time_c, xlab=&#39;Number of events&#39;, ylab=&#39;Time&#39;, type=&#39;b&#39;, main=&#39;Timeline given number of events&#39;, lwd=2)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-17-1.png" width="50%" height="100%" /><img src="index_files/figure-html/unnamed-chunk-17-2.png" width="50%" height="100%" /></p>
<pre class="r"><code>event_curve</code></pre>
<pre><code>## $T_all
##   at analysis_time analysis_time_c  event subjects    median   prop_12
## 1 20            20      2021-08-31 144.32      400  7.433767 0.2753500
## 2 30            30      2022-07-02 274.66      600  9.697377 0.4127667
## 3 40            40      2023-05-02 413.06      800 11.473202 0.4826000
## 4 50            50      2024-03-01 552.66     1000 12.787177 0.5230000
## 5 60            60      2024-12-31 638.74     1000 17.289703 0.6614000
## 6 70            70      2025-10-31 688.84     1000 21.580575 0.6893600
## 7 80            80      2026-09-01 696.52     1000 22.728576 0.6893600
## 8 90            90      2027-07-02 697.72     1000 22.728576 0.6893600
## 
## $T_by_group
##    at group analysis_time analysis_time_c  event subjects    median   prop_12
## 1  20   con            20      2021-08-31 103.46   264.72  7.465250 0.2756532
## 9  20   trt            20      2021-08-31  40.86   135.28  7.325042 0.2743635
## 2  30   con            30      2022-07-02 194.72   398.62  9.621990 0.4104070
## 10 30   trt            30      2022-07-02  79.94   201.38  9.834988 0.4174446
## 3  40   con            40      2023-05-02 289.84   532.46 11.400978 0.4794756
## 11 40   trt            40      2023-05-02 123.22   267.54 11.650632 0.4887271
## 4  50   con            50      2024-03-01 386.00   666.32 12.712905 0.5207442
## 12 50   trt            50      2024-03-01 166.66   333.68 12.883114 0.5275161
## 5  60   con            60      2024-12-31 443.04   666.32 17.235296 0.6593266
## 13 60   trt            60      2024-12-31 195.70   333.68 17.452335 0.6655516
## 6  70   con            70      2025-10-31 474.46   666.32 21.533297 0.6875715
## 14 70   trt            70      2025-10-31 214.38   333.68 21.820031 0.6929413
## 7  80   con            80      2026-09-01 478.34   666.32 22.566857 0.6875715
## 15 80   trt            80      2026-09-01 218.18   333.68 23.026074 0.6929413
## 8  90   con            90      2027-07-02 478.80   666.32 22.566857 0.6875715
## 16 90   trt            90      2027-07-02 218.92   333.68 23.026074 0.6929413</code></pre>
<pre class="r"><code>time_curve</code></pre>
<pre><code>## $T_all
##    at analysis_time analysis_time_c event subjects    median   prop_12
## 1 200      24.37533      2022-01-11   200   487.32  8.497308 0.3509681
## 2 250      28.16769      2022-05-07   250   563.58  9.314588 0.3951767
## 3 300      31.87696      2022-08-28   300   637.62 10.103410 0.4288246
## 4 350      35.42872      2022-12-14   350   709.22 10.733624 0.4549033
## 5 400      39.05356      2023-04-03   400   781.50 11.328161 0.4779267
## 6 450      42.67328      2023-07-22   450   853.18 11.868305 0.4954207
## 7 500      46.20119      2023-11-07   500   924.10 12.319780 0.5093769
## 8 550      49.77912      2024-02-24   550   989.94 12.878765 0.5249844
## 9 600      54.55579      2024-07-18   600  1000.00 14.858703 0.5848200</code></pre>
<p><br></p>
</div>
</div>
<div id="ref" class="section level1">
<h1>Reference</h1>
<p>[1] Muggeo, V. M. (2003). Estimating regression models with unknown
break-points. Statistics in medicine, 22(19), 3055-3071.</p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
